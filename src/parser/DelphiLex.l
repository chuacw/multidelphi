using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;
using System.Globalization;

namespace MultiPascal.Parser
{

/**
 * Delphi Lexer
 * Generated by C# Flex, based on <a href="http://www.jflex.de/">JFlex</a>.
 */
 
%%

	// TODO make a debug option programatically configurable	
// %debug
// %standalone

	
	// %public %abstract
%class DelphiScanner
%implements Token, IScanner
//%extends 
%function token

%8bit
	// %unicode

// useless for C#
// %yylexthrow ScannerException

//%column
%line
//Delphi is case insensitive, but the stringstream has been converted to lowercase. Simpler and faster
//%ignorecase

// ------------------------------------------------------
// EOF treatment:
%integer	// eof type. same as: %type Int32

%eofval{
	// code to be injected in all non-specified <STATE><<EOF>> rules
	return YYEOF;
%eofval}

%eofclose	// close the stream at EOF
/*
%eof{
	// code to be injected in zzDoEOF() if (!zzEOfDone)
%eof}
*/

// ------------------------------------------------------

%init{
	// code injected in the constructor
	// Inits the scanner
	InitLexer(@in);
%init}

%{
		// **********************************************
		// IScanner/yyLex interface:

		public bool advance () {
			return !zzAtEOF;
		}

		// public int token ();	// created by CSFlex
		
		public Object value () {
			return yylval;
		}

		public int yylineno() {
			return yyline;
		}

		
		// **********************************************
		// Internal helper functions
			
		
		UInt64 GetInt(string str, int numbase)
		{
			try {
				return Convert.ToUInt64(str, numbase);
			}
			catch (OverflowException)
			{	yyerror("Value exceeds the maximum range for an integer constant (2^64)");
				return 0;
			}
		}
		
		Double GetReal(string str)
		{
			try {
				return Double.Parse(str, CultureInfo.InvariantCulture);
			}
			catch (OverflowException)
			{	yyerror("Value exceeds the maximum range for an floating-point constant");
				return 0.0;
			}
		}

		string GetDirectiveArg(string directive)
		{
			int ignlen = directive.Length + 2; // from: "{$"
			return yytext().Substring(ignlen, yylength()-1-ignlen).Trim();
		}	
		
		Object InitialLval = typeof(DelphiScanner);	// non-conflicting value
		
		void InitLexer(TextReader sr)
		{
			stateNames = new string[] {
				"INITIAL", "XASMCODESEC", "XFUNCDECL", "XFUNCPARAMS", "XFUNCDIRECTS",
				"XFUNCEXTERN", "SPROPSPECS", "SPACKAGES", "SCLASS" };

			yyreset(sr);
			// set yylval and text to null before each executing each rule's action
			PRE_ACTION_DEFAULT = () => { yylval = null; text = null; };
	
			stateStack.Push(INITIAL);
			
			yylval = InitialLval;	// signal that the strat state, no match done yet
		}
		
		int ProcessIdentifier(string id)
		{
			yylval = id;
			return IDENTIFIER;
		}
	
%}


	// exclusive states
%x XASMCODESEC XFUNCDECL XFUNCPARAMS XFUNCDIRECTS XFUNCEXTERN
	// inclusive states. shared with INITIAL
%s SPROPSPECS SPACKAGES SCLASS

DEC     = [0-9]
HEXA    = [0-9a-f]
ID      = [0-9a-z_]
ID1		= [_a-z]
NL      = (\r|\n|\r\n)
	

%%


	/**************************************************************/
	/* Reserved keywords	*/

	/* file type */
library		{ return KW_LIBRARY; }
unit		{ return KW_UNIT; }
program		{ return KW_PROGRAM; }

	/* dependencies */
uses		{ return KW_USES; }
exports		{ return KW_EXPORTS; }

	/* units keywords */
interface		{ return KW_INTERF; }
implementation	{ return KW_IMPL; }
finalization	{ return KW_FINALIZ; }
initialization	{ return KW_INIT; }

	/* objects */
class		{ yypushstate(SCLASS); return KW_CLASS; }
object		{ yypushstate(SCLASS); return KW_OBJECT; }
record		{ return KW_RECORD; }
packed		{ return KW_PACKED; }		// packed struct
of			{ return KW_OF; }			// decl of types
out			{ return KW_OUT; }			// modifier of func params
absolute	{ return KW_ABSOLUTE; }		// modifier of variables
property	{ yypushstate(SPROPSPECS); return KW_PROPERTY; }
inherited	{ return KW_INHERITED; }	// call of base construcotr/methods

	/* functions */
function	{ yypushstate(XFUNCDECL); return KW_FUNCTION; }
procedure	{ yypushstate(XFUNCDECL); return KW_PROCEDURE; }
constructor	{ yypushstate(XFUNCDECL); return KW_CONSTRUCTOR; }
destructor	{ yypushstate(XFUNCDECL); return KW_DESTRUCTOR; }

	/* section headers */
const		{ return KW_CONST; }
var			{ return KW_VAR; }
threadvar	{ return KW_THRVAR; }
type		{ return KW_TYPE; }
resourcestring	{ return TYPE_RSCSTR; }

	/* blocks */
begin		{ return KW_BEGIN; }
with		{ return KW_WITH; } 	// with x do stmt
do			{ return KW_DO; }

	/* control flow: loops */
for			{ return KW_FOR; }
to			{ return KW_TO; }
downto		{ return KW_DOWNTO; }
repeat		{ return KW_REPEAT; }
until		{ return KW_UNTIL; }
while		{ return KW_WHILE; }
break		{ return KW_BREAK; }
continue	{ return KW_CONTINUE; }

	/* control flow: others */
if			{ return KW_IF; }
then		{ return KW_THEN; }
else		{ return KW_ELSE; }
case		{ return KW_CASE; }
goto		{ return KW_GOTO; }
label		{ return KW_LABEL; }

	/* control flow: exceptions */
raise		{ return KW_RAISE; }
at			{ return KW_AT; }	// ex: raise excpt at address
try			{ return KW_TRY; }
except		{ return KW_EXCEPT; }
finally		{ return KW_FINALLY; }
on			{ return KW_ON; }




	/**************************************************************
	 * Directives:
	 * Should be treated as identifiers instead of reserved keywords
	 **************************************************************/

 	/**************************************************************/
	// Lexical Scope for function directives

	// wait for function params or return (when function has no params)
<XFUNCDECL> {
	// function name
	{ID1}{ID}*	{ return ProcessIdentifier(yytext()); }
	"."			{ return KW_DOT; }
	
	"("			{	switchcallback(XFUNCPARAMS, INITIAL);
					return LPAR;
				}
	";"			{	switchstate(XFUNCDIRECTS);
					return SCOL;
				}
	":"			{	switchcallback(XFUNCDIRECTS, INITIAL);
					return COLON;
				}
	[ \t\n\r]+	{ }
	. 			{ // signal to leave this state
					yypopstate();
					yypushback(1);
				}
}

	// after scanning func params, wait for function return
<XFUNCPARAMS> {
	":"			{	switchcallback(XFUNCDIRECTS, INITIAL);
					return COLON;
				}
	
	";"			{	switchstate(XFUNCDIRECTS);
					return SCOL;
				}
				
	[ \t\n\r]+	{ }
	. 			{ // signal to leave this state
					yypopstate();
					yypushback(1);
				}
}
	
	// scan function directives. in the default state, emit them as identifiers
<XFUNCDIRECTS> {
		// function call conventions
	cdecl		{ return KW_CDECL; }
	pascal		{ return KW_PASCAL; }
	mwpascal	{ return KW_PASCAL; }
	register	{ return KW_REGISTER; }
	safecall	{ return KW_SAFECALL; }
	stdcall		{ return KW_STDCALL; }

		// function qualifiers
	abstract	{ return KW_ABSTRACT; }
	assembler	{ return KW_ASSEMBLER; }
	dynamic		{ return KW_DYNAMIC; }
	export		{ return KW_EXPORT; }
	forward		{ return KW_FORWARD; }
	inline		{ return KW_INLINE; }
	override	{ return KW_OVERRIDE; }
	overload	{ return KW_OVERLOAD; }
	reintroduce	{ return KW_REINTRODUCE; }
	virtual		{ return KW_VIRTUAL; }
	varargs		{ return KW_VARARGS; }
		// DOS deprecated
	far			{ return KW_FAR; }
	near		{ return KW_NEAR; }
	resident	{ return KW_RESIDENT; }
	
		// needs to chomp up the externa args
	external	{ yypushstate(XFUNCEXTERN); return KW_EXTERNAL; }
	
	";"			{ return SCOL; }
	[ \t\n\r]+	{ }

	// leave func directives:
	"="			{ yypopstate(); return KW_EQ; }
		// for IDs that start with a keyword part. ex: forward_dffdg
	{ID1}{ID}*	{ yypopstate(); yypushback(yylength()); }
	. 			{ yypopstate();	yypushback(1); }
}

	// process 'external' directive args
<XFUNCEXTERN> {
	name 		{ return KW_NAME; }
	'[^']*'		{ yylval = yytext().Substring(1, yylength()-2); return CONST_STR; }
	"."			{ return KW_DOT; }
	{ID1}{ID}*	{ return ProcessIdentifier(yytext()); }
	
	";"			{ yypopstate(); return SCOL; }
	[ \t\n\r]+	{ }
	.			{ yyerror("Invalid char in external args: " + text + " (ASCII " + ((int) text[0]) +")"); }	
} 

	
 	/**************************************************************/
	// Lexical Scope for Properties directives	

<SPROPSPECS> {
	//	properties keywords
	default		{ return KW_DEFAULT; }
	index		{ return KW_INDEX; }
	implements	{ return KW_IMPLEMENTS; }
	nodefault	{ return KW_NODEFAULT; }
	read		{ return KW_READ; }
	stored		{ return KW_STORED; }
	write		{ return KW_WRITE; }

	";" 		{ // signal to leave this state
					yypopstate();
					return SCOL;
				}
				
				// array properties
	"["			{ yypushstate(INITIAL); return LBRAC; }
}


 	/**************************************************************/
	// Lexical Scope for Visibility/Scope qualifiers - TODO

<SCLASS> {
	protected	{ return KW_PROTECTED;	}
	public		{ return KW_PUBLIC;		}
	published	{ return KW_PUBLISHED;	}
	private		{ return KW_PRIVATE;	}

		//signal to leave this state
	end			{	yypopstate();
					return KW_END;
				}
}

end				{ return KW_END; }

	
 	/**************************************************************/
	// Lexical Scope for Packages
	
package			{	// if it's the first token in the src file, it's a package keywod:
					if (yylval == InitialLval) 
					{	yypushstate(SPACKAGES); 
						return KW_PACKAGE;
					}
					// else, just an identifier
					return ProcessIdentifier(yytext());
				}
<SPACKAGES> {
	requires	{ return KW_REQUIRES; }
	contains	{ return KW_CONTAINS; }
}


 	/**************************************************************/
	/* Built-in types: emitted as identifiers */
	/*
			// types: integers
		byte		{ return TYPE_BYTE; }
		shortint	{ return TYPE_SHORTINT; }
		word		{ return TYPE_WORD; }
		smallint	{ return TYPE_SMALLINT; }
		cardinal	{ return TYPE_CARDINAL; }
		integer		{ return TYPE_INT; }
		longword	{ return TYPE_LONGWORD; }
		longint		{ return TYPE_LONGINT; }
		int64		{ return TYPE_INT64; }
		uint64		{ return TYPE_UINT64; }
		comp		{ return TYPE_COMP; }

			// types: floats
		single		{ return TYPE_FLOAT; }
		real48		{ return TYPE_REAL48; }
		extended	{ return TYPE_EXTENDED; }
		double		{ return TYPE_DOUBLE; }
		real		{ return TYPE_DOUBLE; }
		currency	{ return TYPE_CURR; }

			// types: chars 
		char		{ return TYPE_CHAR; }
		pchar		{ return TYPE_PCHAR; }
		ansichar	{ return TYPE_PCHAR; }
		widechar	{ return TYPE_WIDECHAR; }
		shortstring	{ return TYPE_SHORTSTR; }
		widestring	{ return TYPE_WIDESTR; }
		ansistring	{ return TYPE_STR; }
		 
			// types others
		boolean		{ return TYPE_BOOL; }
		olevariant	{ return TYPE_OLEVAR; }
		variant		{ return TYPE_VAR; }
	*/

string		{ return TYPE_STR; }
array		{ return TYPE_ARRAY; }
pointer		{ return TYPE_PTR; }
file		{ return TYPE_FILE; }
set			{ return TYPE_SET; }
		

	/**************************************************************/
	/* ASM x86 */

asm					{	yypushstate(XASMCODESEC);
						return KW_ASM;
					}
<XASMCODESEC> {
 [ \t\r]+			{ }
 end				{	yypopstate();
						return KW_END;
					}
	// ignore IDs that start with 'end'
 {ID1}{ID}*			{ }

 .|{NL}				{ }	// return ASM_OP; }
}


	/**************************************************************/
	/* Literals	*/
	
	/* literals: numeric */
{DEC}+				{ yylval = GetInt(yytext(),10); return CONST_INT; }
\${HEXA}+			{ yylval = GetInt(yytext().Substring(1), 16); return CONST_INT; }
nil					{ return CONST_NIL; }
{DEC}+\.{DEC}+		{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
{DEC}+\.{DEC}+e[+-]?{DEC}+	{ yylval = GetReal(yytext()); return CONST_REAL; }
	
	/* literals: Alphanumeric */
'.'					{ yylval = (UInt64) yytext()[1]; return CONST_CHAR; }
					// check that num < 255
\#{DEC}+			{ yylval = GetInt(yytext().Substring(1), 10); return CONST_CHAR; }
\#\${HEXA}+			{ yylval = GetInt(yytext().Substring(2), 16); return CONST_CHAR; }
					// unterminated strings have been purged during preprocessing
'[^']*'				{ yylval = yytext().Substring(1, yylength()-2); return CONST_STR; }

true				{ yylval = true;  return CONST_BOOL; }
false				{ yylval = false; return CONST_BOOL; }


	/**************************************************************/
	/* Operators	*/
	
	/* separators */
":"			{ return COLON; }
","			{ return COMMA; }
"["			{ return LBRAC; }
"("			{ return LPAR ; }

"]"			{ if (yylaststate() == SPROPSPECS  ) yypopstate(); return RBRAC;}
";"			{ if (yylaststate() == XFUNCDIRECTS) yypopstate(); return SCOL; }
")"			{ if (yylaststate() == XFUNCPARAMS ) yypopstate(); return RPAR; }

	/* expr: general */
":="		{ return KW_ASSIGN; }
".."		{ return KW_RANGE; }
as			{ return KW_AS; }	// cast

	/* expr: unary pointer access */
"."			{ return KW_DOT; }
"@"			{ return KW_ADDR; }
"^"			{ return KW_DEREF; }

	/* expr: numeric operators */
"-"			{ return KW_SUB; }
"+"			{ return KW_SUM; }
"/"			{ return KW_DIV; }
"*"			{ return KW_MUL; }
div			{ return KW_QUOT;}
mod			{ return KW_MOD; }

	/* expr: logical operators */
and			{ return KW_AND; }
or			{ return KW_OR;	 }
xor			{ return KW_XOR; }
shl			{ return KW_SHL; }
shr			{ return KW_SHR; }
not			{ return KW_NOT; }

	/* expr: comparison operators */
"<"			{ return KW_LT; }
">"			{ return KW_GT; }
">="		{ return KW_GE; }
"<="		{ return KW_LE; }
"="			{ return KW_EQ; }
"<>"		{ return KW_NE; }
is			{ return KW_IS; }	// type comp
in			{ return KW_IN; }	// is in set




	/**************************************************************/

{ID1}{ID}*	{ return ProcessIdentifier(yytext()); }

[ \t]+		{ }     /* ignore whitespace */

{NL}		{ }

.			{ yyerror("Unknown char: " + text + " (ASCII " + ((int) text[0]) +")"); }



	/************************************************************/
	/* Obscure/Non-portable/Deprecated keywords: not supported	*/
	
	/* file warnings */
	/*
	platform	{ return KW_PLATFORM; }
	deprecated	{ return KW_DEPRECATED; }
	*/

	/* Embarcadero Delphi directives - ignored
	delayed experimental final
	helper operator reference
	sealed static strict unsafe
	*/

	/*		// windows/forms/COM specific - ignored
	winapi		{ return KW_WINAPI; }
	message		{ return KW_MESSAGE; }
	dispinterface	{ return KW_DISPINTERF; }
	dispid		{ return KW_DISPID; }
	automated	{ return KW_AUTOMATED; }	// visibilidade
		// properties modifiers for dispinterface
	writeonly	{ return KW_WRITEONLY; }
	readonly	{ return KW_READONLY; }
	*/

%%

}	// close outermost namespace
