using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;

namespace crosspascal.parser
{

/**
 * Delphi Lexer
 * Generated by C# Flex, based on <a href="http://www.jflex.de/">JFlex</a>.
 */
	
%%
	
//%abstract
%public 
%class DelphiPreprocessor
//%implements
//%extends 
%function Preprocess

%8bit
	// %unicode
	
//%column
%line
	//Delphi is case insensitive
%ignorecase

// ------------------------------------------------------
// EOF treatment:
%integer	// eof type. same as: %type Int32

/*	// Use explicit <<EOF>> rules instead 
%eofval{
	// code to be injected in non-specified <STATE><<EOF>> rules
	return YYEOF;
%eofval}
*/

// %eofclose	// close the stream at EOF
%eof{
	// code to be injected in zzDoEOF() if (!zzEOfDone)
	zzEOFDone = false;	// revert changes of zzDoEOF()! Should only apply to the top-level stream
%eof}
// ------------------------------------------------------

%init{
	// code injected in the constructor
	// Inits the scanner
	ResetPreprocessor(@in);
%init}

%{
		// **********************************************
		// Creation and control
	
		String FileName;
		
		int countErrors;

		public DelphiPreprocessor()
		{
			zzReader = null;
		}

		public void ResetPreprocessor(string fname)
		{
			FileName = fname;
			countErrors = 0;
			StreamReader sr = new StreamReader(fname, DefaultEncoding);
			ResetPreprocessor(sr);
		}

		public void ResetPreprocessor(TextReader sr)
		{	
			yyreset(sr);
			ResetPreprocessor();
			outBuilder = new StringBuilder();
			
			// for debug
			stateNames = new string[] {"INITIAL", "XCOMMENT1", "XCOMMENT2", "XNOTDEF" };
			stateStack.Push(INITIAL);
		}
		
		void pperror(String msg = "Unknown preprocessing error")
		{
			countErrors++;
			Console.ForegroundColor = ConsoleColor.Red;
			Console.Error.WriteLine("[ERROR preprocessor] " + msg + " in File " + FileName  + " line " + yyline);
			Console.ResetColor();
		}


		// **********************************************
		// Directives processing
	
		Stack<Boolean> defines = new Stack<Boolean>();
	
		string GetDirectiveArg(string directive)
		{
			int ignlen = directive.Length + 2; // from: "{$"
			return yytext().Substring(ignlen, yylength()-1-ignlen).Trim();
		}	

		bool IsDefinedDir(string dir)
		{
			Boolean defined = IsDefined(GetDirectiveArg(dir));
			defines.Push(defined);
			return defined;
		}
		
		
		// **********************************************
		// Output Building
				
		StringBuilder outBuilder;
		
		public string GetOutput()
		{
			return outBuilder.ToString().ToLowerInvariant();	// Delphi is case-insensitive
		}

		// Emit newline if the current stream is the original src file
		void CheckSourceNewline()
		{
			if (!yymoreStreams())
				outBuilder.Append('\n');
		}
		
		
%}


	// exclusive states
%x XCOMMENT1 XCOMMENT2 XNOTDEF

	/* chomp up as much input as possible in one match */ 
ANYCHAR	= [ \t_a-zA-Z0-9:;!#.,=&*@><\\@$\[\]\^+\-]

NL      = (\r|\n|\r\n)	

%%

	/**************************************************************/
	/* Comments		*/

"//".*				{ }
\{					{ yypushstate(XCOMMENT1); }
\(\*				{ yypushstate(XCOMMENT2); }

<XCOMMENT1>\}		{ yypopstate(); }
<XCOMMENT2>\*\)		{ yypopstate(); }

<XCOMMENT2,XCOMMENT1> {
 {ANYCHAR}			{ }
 [*'')]				{ }
 {NL}				{ CheckSourceNewline(); }
 .					{ }
 <<EOF>>			{ throw new PreprocessorException(yyline, "Unterminated comment"); }
}


	/**************************************************************/
	/* PreProcessor - process compiler directives */
	
	
	/* includes */
"{$i "[^}]+\}		{
						string ifile = GetDirectiveArg("i");
						string inctext = FetchInclude(ifile);
						
						if (inctext == null)
						{	pperror("Include file " + ifile + " not found");
							break;
						}

						StringReader sr = new StringReader(inctext);
						yypushStream(sr);
						yydebug("Pushed stream from " + ifile + "");
					}

	/* defines */
"{$define "[^}]+\}	{	AddDefine(GetDirectiveArg("define"));	}

"{$undef "[^}]+\}	{	RemoveDefine(GetDirectiveArg("undef"));	}

	/* ifdefs */
"{$ifdef "[^}]+\}	{	if (!IsDefinedDir("ifdef"))
							yypushstate(XNOTDEF);
					}

"{$ifopt "[^}]+\}	{	if (!IsDefinedDir("ifopt"))
							yypushstate(XNOTDEF);
					}

"{$ifndef "[^}]+\}	{	Boolean defined = IsDefined(GetDirectiveArg("ifndef"));
						defines.Push(!defined);
						if (defined)
							yypushstate(XNOTDEF);
					}

"{$else"[^}]*\}		{	// currently in a defined section, switch to non-defined
						defines.Pop();
						defines.Push(false);
						yypushstate(XNOTDEF);
					}

"{$endif"[^}]*\}	{ defines.Pop(); }


/* Other compiler directives: ignored for now */
"{$"[^}]\}			{ }

	/* not-defined code section */
<XNOTDEF> {
 "//".*				{ }
 \{					{ yypushstate(XCOMMENT1); }
 \(\*				{ yypushstate(XCOMMENT2); }
 
					/* push true to signal that these defines are within a non-defined section */
 "{$ifdef "[^}]+\}	{ defines.Push(true); }

 "{$ifopt "[^}]+\}	{ defines.Push(true); }

 "{$ifndef "[^}]+\}	{ defines.Push(true); }

 "{$else"[^}]*\}	{	if (defines.Peek() == false)	// at the non-def section start, must leave
						{	yypopstate();
							defines.Pop();
							defines.Push(true);
						} // else, leave the top def as true
					}

 "{$endif"[^}]*\}	{	Boolean def = defines.Pop(); 
						if (def == false)
							yypopstate();
					}
 
 {ANYCHAR}+			{ /* chomp up as much as possible in one match */ }
 {NL}				{ CheckSourceNewline(); }
 .					{ /* ignore everything in a non-def section */ }
 <<EOF>>			{ throw new PreprocessorException(yyline, "Unterminated #ifdef"); }
}


	/**************************************************************/

{ANYCHAR}+			{ outBuilder.Append(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead); }

'[^\n\r']*('|{NL})	{	if (zzBuffer[zzMarkedPos-1] != '\'')	// if last char not quote
							pperror("Unterminated string");
						else
							outBuilder.Append(zzBuffer, zzStartRead, zzMarkedPos-zzStartRead);
					}

\/|\(|\)			{ outBuilder.Append(yycharat(0)); }
{NL}				{ CheckSourceNewline(); }

<<EOF>>				{	if (yymoreStreams())
						{
							yypopStream();
							yydebug("Popped stream and began initial state");
						}
						else
						{
							if (defines.Count > 0)
								throw new PreprocessorException(yyline, "Unterminated #ifdef");
							
							if (countErrors > 0)
								throw new PreprocessorException(yyline, "Errors during preprocessing");
							
							return Accept(); /* top-level yyclose() */						
						}
					}

.					{ pperror("Unknown char: " + text + " (ASCII " + ((int) text[0]) +")"); }


%%

}	// close outermost namespace
